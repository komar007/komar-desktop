# /etc/skel/.bashrc
#
# This file is sourced by all *interactive* bash shells on startup,
# including some apparently interactive shells such as scp and rcp
# that can't tolerate any output.  So make sure this doesn't display
# anything or bad things will happen !

# Test for an interactive shell.  There is no need to set anything
# past this point for scp and rcp, and it's important to refrain from
# outputting anything in those cases.
if [[ $- != *i* ]] ; then
	# Shell is non-interactive.  Be done now!
	return
fi

# if we have an original file
if [ -f ~/.bashrc_orig ]; then
	source ~/.bashrc_orig
fi
unset command_not_found_handle

HISTCONTROL=

# ALIASES

unalias -a
alias ls="ls --color=always"
alias grep="grep --colour=auto"
alias e="e -F"
alias t="ps -p $$ -o start_time"
for prog in kicad pcbnew eeschema oowriter ooimpress oocalc oobase oodraw audacity libreoffice; do
	alias $prog="GTK2_RC_FILES=/usr/share/themes/Default/ $prog"
done

function less_set_title()
{
	dir="$(pwd)"
	echo "$(tput tsl)less $@ [$dir]$(tput fsl)"
	less "$@"
}
alias less=less_set_title

function tig_set_title()
{
	dir="$(dirname "$(cd "$(git rev-parse --git-dir 2> /dev/null)"; pwd)")"
	branch="$(git rev-parse --abbrev-ref HEAD 2> /dev/null)"
	if [ -n "$branch" ]; then
		dir+=" on $branch"
	fi
	title="tig"
	argline="$@"
	if [ -n "$argline" ]; then
		title+=" $argline"
	fi
	echo "$(tput tsl)$title [$dir]$(tput fsl)"
	tig "$@"
}
alias tig=tig_set_title


# UTILITIES

prepend_path() {
    [[ ":$PATH:" != *":$1:"* ]] && PATH="$1${PATH:+":$PATH"}"
}

function share()
{
	scp "$1" komar@komar.be:/var/www/space.komar.be/htdocs/
	echo http://space.komar.be/`basename "$1"`
}

function notify() {
	NOBLOCK=0
	if [ "$1" == "--noblock" ]; then
		NOBLOCK=1
		shift
	fi
	[ -n "$*" ] && echo -ne "\e]0;$*\a"
	echo -ne "$*...\a"
	[ "$NOBLOCK" -eq 0 ] && read
}


# COMPLETION

if [ -f /usr/share/mc/mc.gentoo ]; then
	. /usr/share/mc/mc.gentoo
fi

[[ -f /etc/profile.d/bash-completion.sh ]] && source /etc/profile.d/bash-completion.sh
# suppress tilde-expansion
_expand()
{
	return 0;
}


# SHELL PROMPT

# predicates
# shellcheck disable=SC2016
p_is_git='[[ -n "$(git rev-parse --git-dir 2> /dev/null)" ]]'
# shellcheck disable=SC2016
p_command_executed='[ -n "$_LAST_TIME" ]'
# shellcheck disable=SC2016
p_is_ssh='[[ "$(pstree -clspA $BASHPID | head -n 1)" =~ sshd.+\($BASHPID\) ]]'
# shellcheck disable=SC2016
p_is_nixshell='[ -n "$NIX_SHELL_NAME" ]'
# shellcheck disable=SC2016
p_is_venv='[ -n "$VIRTUAL_ENV" ]'
# shellcheck disable=SC2016
p_cmd_ok='[[ $_LAST_EXIT_CODE -eq 0 ]]'
# strings
# shellcheck disable=SC2016
p_git_branch='$(git rev-parse --abbrev-ref HEAD 2>/dev/null)'
# shellcheck disable=SC2016
p_time='$(date +" %H:%M:%S ")'
# shellcheck disable=SC2016
p_ps1_extra_exists='[[ -n "$PS1_EXTRA" ]]'

function p_if_else()
{
	cond=$1
	yes=$2
	no=$3
	echo -n "\$(if $cond; then echo -n "'"'"$yes"'"'"; else echo -n "'"'"$no"'"'"; fi)"
}
function p_if()
{
	p_if_else "$1" "$2" ""
}

function p_if_last_cmd_succ()
{
	p_if_else "[[ \$_LAST_EXIT_CODE -eq 0 ]]" "$1" "$2"
}

function p_token()
{
	prefix=$1
	str=$2
	suffix=$3
	quoted='"'$str'"'
	p_if "-n $quoted" "$prefix$str$suffix"
}
function p_set_title()
{
	title="$*"
	# shellcheck disable=SC2028
	echo -n "\[\e]0;$title\a\]"
}
function print_hline()
{
	if grep -q tmux- <<< "$TERM"; then
		setterm -linewrap off
		yes ┈ | head -n $COLUMNS | tr -d '\n'
		setterm -linewrap on
	else
		tput cuf $COLUMNS
	fi
}
function p_right()
{
	cmd1="$1"
	cmd2="$2"
	dim_color="$(tput sgr0 setaf 0)"
	choose_color="$(p_if_last_cmd_succ "${DIMBLUE}" "${DIMRED}")"
	h_line="\$(print_hline)"
	back_to_2="\$(tput cub \$(wc -m <<< \"$cmd2\"))"
	back_to_1="\$(tput cub \$((\$(wc -m <<< \"$cmd2\") + \$(wc -m <<< \"$cmd1\"))))"
	# shellcheck disable=SC2028
	echo -n "$choose_color\[\e7$h_line$back_to_2$dim_color$cmd2$back_to_1$cmd1\e8\]${RESET}"
}

RESET="\[$(tput sgr0)\]"
INVERT="\[$(tput rev)\]"

GRAY="\[$(tput setaf 0)\]"
BGRAY="\[$(tput bold setaf 0)\]"
RED="\[$(tput setaf 1)\]"
DIMRED="\[$(tput dim setaf 1)\]"
BBLUE="\[$(tput bold setaf 4)\]"
DIMBLUE="\[$(tput dim setaf 4)\]"
BLUE="\[$(tput setaf 4)\]"
GREEN="\[$(tput setaf 2)\]"
BYELLOW="\[$(tput bold setaf 3)\]"
YELLOW="\[$(tput setaf 3)\]"
BLACK="\[$(tput setaf 16)\]"
LGRAY="\[$(tput setaf 249)\]"

BG_GRAY="\[$(tput setab 236)\]"

function get_ps1()
{
	if grep -q rxvt <<< "$TERM"; then
		PLUS=+
		MINUS=-
	else
		PLUS=" "
		MINUS=" "
	fi

	SECTION_BEGIN="${BG_GRAY}${BLACK}"
	SECTION_END="${BLACK}${INVERT}$RESET"

	# shellcheck disable=SC2016
	p_git_stats=' $(git diff-index  --shortstat  HEAD -- 2>/dev/null \
	    | sed -r -e "s/[^,]+, ([0-9]+[^,]+)(, ([0-9]+.*))?/\1 \3/" \
	             -e "s/([0-9]+) [a-z]+\(\+\)/'${GREEN}$PLUS'\1/g" \
		     -e "s/([0-9]+) [a-z]+\(\-\)/'${RED}$MINUS'\1/g" \
		     -e "s/ +$//")'

	prev_status="$(p_if_else "$p_cmd_ok" "${BLUE}" "${RED}${INVERT}\$?${RESET}${RED}")"${RESET}
	# shellcheck disable=SC2153
	ps1_extra="$(p_if "$p_ps1_extra_exists" " ($PS1_EXTRA)")"
	ssh_tag="$(p_if "$p_is_ssh" "${BYELLOW}ssh:${RESET}")"
	nix_tag="$(p_if "$p_is_nixshell" "${SECTION_BEGIN} ${BBLUE}󱄅 ${LGRAY}\$NIX_SHELL_NAME${SECTION_END}")"
	# shellcheck disable=SC2016,SC2089
	venv_path='$(realpath --relative-to="$(pwd)" "$VIRTUAL_ENV" 2>/dev/null)'
	venv_tag="$(p_if "$p_is_venv" "${SECTION_BEGIN} ${BBLUE} ${GRAY}$venv_path${SECTION_END}")"
	branch_token="$(p_if "$p_is_git" "${SECTION_BEGIN}${YELLOW}⎇ $p_git_branch${GRAY}$p_git_stats${SECTION_END}${RESET}")"
	# shellcheck disable=SC2016
	last_exec_time="$(p_if "$p_command_executed" '$(echo \  $_LAST_TIME)s ')"
	right_tag="$(p_right "$last_exec_time" "$p_time")"
	title="bash: \\W $(p_if "$p_is_git" "on $p_git_branch")"

	ssh_tag=$(eval echo "$ssh_tag") # needs to be evaluated just once

	twoline="$right_tag"
	twoline+="$prev_status$ps1_extra$branch_token$nix_tag$venv_tag"
	twoline+=" ${GREEN}\u${BGRAY}@${RESET}$ssh_tag${GREEN}\h${BGRAY}:${RESET}${BLUE}\w${GRAY} "
	twoline+="${RESET}\n"
	twoline+="  ${BBLUE}\\\$${RESET} $(p_set_title "$title")"

	echo -e "$twoline"
}
PS1=$(get_ps1)


# GLOBAL HISTORY

# Trim the input from whitespace and convert to a json-friendlt string literal
function _trim_jsonize_string()
{
	jq -MR --slurp '. | gsub("^\\s+|\\s+$";"")'
}

# Remove the history item number from the output of "history 1"
# Note: it is only guaranteed to work with a single item of history, because it may be multi-line
function _remove_history_id()
{
	sed -r '1s/\s+[0-9]+\s+//'
}

# Output the input lines as they are or "null" if the input is empty
function _or_null()
{
	awk '//{x=1;print} END{if(!x)print("null")}'
}

_LAST_HIST=""
# Prepare a single-line json-formatted command history entry
function _format_history_entry()
{
	(
		date +%s
		[ -n "$TMUX" ] \
			&& tmux display-message -p '#S' | _trim_jsonize_string \
			|| echo null
		HISTTIMEFORMAT="%s%n" history 1 \
			| head -n 1 \
			| _remove_history_id \
			| _or_null
		HISTTIMEFORMAT="" history 1 \
			| _remove_history_id \
			| _trim_jsonize_string
		pwd | _trim_jsonize_string
		[ -n "$OLDPWD" ] \
			&& echo "$OLDPWD" | _trim_jsonize_string \
			|| echo null
		echo "$_LAST_EXIT_CODE"
		date +%s%N | _trim_jsonize_string
	) \
		| jq -Mc --slurp '{
			cmd: .[3],
			start: .[2],
			end: .[0],
			cwd: .[4],
			prev_cwd: .[5],
			tmux_session: .[1],
			exit_code: .[6],
			id: .[7]
		} | del(..|nulls)
		  | select(.cmd != "")'
}

function _prompt_command()
{
	_LAST_EXIT_CODE=$?
	local last_start
	local end
	local hist
	hist=$(history 1 | head)
	if [ "$hist" = "$_LAST_HIST" ]; then
		_LAST_TIME=
		return
	fi
	_LAST_HIST="$hist"
	last_start=$(HISTTIMEFORMAT="%s%n" history 1 \
		| head -n 1 \
		| _remove_history_id)
	end=$(date +%s)
	_LAST_TIME=$((end-last_start))
	_format_history_entry >> "$_GLOBAL_HISTORY_FILE"
}

read -r -d '' _JQ_COLORS <<-'EOF'
def colors: {
 "meta": "\u001b[34m",
 "fail": "\u001b[31m",
 "success": "\u001b[32m",
 "warn": "\u001b[33m",
 "dim": "\u001b[30m",
 "reset": "\u001b[0m",
};
EOF

# fzf single history item renderer
read -r -d '' _FZF_ENTRY_JQ <<-'EOF'
"\(.id) "
+ "\(colors.meta)\(.start | strftime("%a %d %b %Y %H:%M:%S"))\(colors.reset)"
+ " " + (if (.exit_code // 0) == 0 then "\(colors.success)[succ]" else "\(colors.fail)[fail]" end) + "\(colors.reset)"
+ " \(.cmd)"
+ (if .end - .start > 1 then " \(colors.warn)(took: \(.end - .start)s)\(colors.reset)" else "" end)
+ (if (.tmux_session != null) then " \(colors.dim):\(colors.meta)\(.tmux_session)\(colors.reset)" else "" end)
+ "\u0000"
EOF
_FZF_ENTRY_JQ="$_JQ_COLORS$_FZF_ENTRY_JQ"

# fzf preview window renderer
read -r -d '' _FZF_PREVIEW_JQ <<-'EOF'
select(.id == $id)
| "$ \(.cmd)\n\n\(colors.meta)"
  + (if (.exit_code // 0) != 0 then "\(colors.fail)" else "" end)
  + "exit code: \(.exit_code)\(colors.meta)\n"
  + "execution time: \(.end - .start)s\n"
  + "@ \(.start | strftime("%a %d %b %Y %H:%M:%S"))\n"
  + "tmux session: \(.tmux_session)\n"
  + (if .prev_cwd then "previous CWD: \(.prev_cwd)\n" else "" end)
  + "CWD: \(.cwd)\n"
EOF
_FZF_PREVIEW_JQ="$_JQ_COLORS$_FZF_PREVIEW_JQ"

_GLOBAL_HISTORY_FILE=$HOME/.global_history

# Show a fuzzy-search prompt with global history and let the user select one item
function _search_global_history()
{
	local directory line bind_id bind id set_cursor preview
	local fzf_extra_opts=$1
	set_cursor="beginning-of-line"$(yes +forward-char | head -n "$READLINE_POINT" | tr -d '\n')
	# shellcheck disable=SC2086
	bind_id=$(tac "$_GLOBAL_HISTORY_FILE" \
		| jq -jr "$_FZF_ENTRY_JQ" \
		| fzf \
			-q "$READLINE_LINE" \
			--bind "start:${set_cursor}" \
			--scheme=history \
			$fzf_extra_opts \
			--ansi \
			--read0 \
			--with-nth=2.. \
			--preview "jq -r --arg id {1} '$_FZF_PREVIEW_JQ' '$_GLOBAL_HISTORY_FILE'" \
			--preview-window=down,wrap,10,border-none \
			--bind "ctrl-y:execute:\
				jq -r 'select(.id == \"{1}\") | .cmd' $_GLOBAL_HISTORY_FILE \
			        | head -c -1 \
				| tmux load-buffer -; \
				tmux save-buffer - \
			        | xsel -i --primary \
			" \
			--color=hl:yellow:bold \
			--color=hl+:yellow:bold \
			--expect enter,ctrl-f \
		| head -n 2 \
		| xargs)
	[ -z "$bind_id" ] && return
	read -r bind id _ <<< "$bind_id"
	case "$bind" in
		enter)
			# jq -r -> command string raw and unquoted
			line=$(jq -r "select(.id == \"$id\") | .cmd" "$_GLOBAL_HISTORY_FILE")
			;;
		ctrl-f)
			# no -r in jq -> directory string already nicely escaped and quoted
			directory=$(jq "select(.id == \"$id\") | .cwd" "$_GLOBAL_HISTORY_FILE")
			line="cd $directory"
			;;
	esac
	READLINE_LINE="$line"
	READLINE_POINT=${#line}
}
bind -x '"\C-g":_search_global_history'
bind -x '"\C-r":_search_global_history "--exact --no-extended --bind ctrl-r:up"'

# save the last history item in global history
PROMPT_COMMAND="_prompt_command"


# ENVIRONMENT VARIABLES

export LESS_TERMCAP_mb=$'\E[1;31m'   # blink
export LESS_TERMCAP_md=$'\E[1;32m'   # bold
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[7m'      # standout
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[1;4;34m' # underline

export FZF_DEFAULT_OPTS=" \
	--color=hl:yellow:bold:underline \
	--color=hl+:yellow:bold \
	--bind=\"ctrl-u:preview-up\"
	--bind=\"ctrl-d:preview-down\"
"

export NIX_SHELL_PRESERVE_PROMPT=1
export VIRTUAL_ENV_DISABLE_PROMPT=1

export EDITOR="nvim"

prepend_path ~/.cargo/bin
prepend_path ~/go/bin
prepend_path ~/.npm-global/bin
prepend_path ~/.local/bin

export GDK_DPI_SCALE=1.6

_BASHRC_RELOADED=1
# start prompt from the bottom (currently not used)
#[ -z "$_BASHRC_RELOADED" ] && seq "$(tput lines)" | sed 's/.//g'

# THE END
